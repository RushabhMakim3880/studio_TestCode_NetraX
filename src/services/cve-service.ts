
'use server';

import { z } from 'zod';
import { format, subDays } from 'date-fns';

// Simplified Zod schemas for the NVD API response
const CveDescriptionSchema = z.object({
  lang: z.string(),
  value: z.string(),
});

const CvssDataSchema = z.object({
  version: z.string(),
  baseScore: z.number(),
  baseSeverity: z.string(),
});

const CvssMetricSchema = z.object({
  source: z.string(),
  cvssData: CvssDataSchema,
});

const CveMetricsSchema = z.object({
  cvssMetricV31: z.array(CvssMetricSchema).optional(),
});

const CveItemSchema = z.object({
  id: z.string(),
  published: z.string(),
  descriptions: z.array(CveDescriptionSchema),
  metrics: CveMetricsSchema.optional(),
});

const NvdVulnerabilitySchema = z.object({
  cve: CveItemSchema,
});

const NvdApiResponseSchema = z.object({
  resultsPerPage: z.number(),
  startIndex: z.number(),
  totalResults: z.number(),
  vulnerabilities: z.array(NvdVulnerabilitySchema),
});

// The simplified data structure our component will use
export type CveData = {
  id: string;
  description: string;
  cvssScore: number;
  publishedDate: string;
};

/**
 * Fetches recent CVEs from the NVD API.
 * @returns A promise that resolves to an array of CveData objects.
 */
export async function getRecentCves(): Promise<CveData[]> {
  const endDate = new Date();
  const startDate = subDays(endDate, 30); // Get CVEs from the last 30 days
  const formattedStartDate = format(startDate, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
  const formattedEndDate = format(endDate, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");

  // Fetch recent critical vulnerabilities.
  // The API is public but has rate limits.
  const url = `https://services.nvd.nist.gov/rest/json/cves/2.0?resultsPerPage=10&pubStartDate=${formattedStartDate}&pubEndDate=${formattedEndDate}&cvssV3Severity=CRITICAL`;

  try {
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`NVD API request failed with status ${response.status}`);
    }

    const data = await response.json();
    const parsedData = NvdApiResponseSchema.parse(data);

    // Map the complex API response to our simplified CveData structure
    return parsedData.vulnerabilities.map(vuln => {
      const cve = vuln.cve;
      const description = cve.descriptions.find(d => d.lang === 'en')?.value || 'No description available.';
      const cvssMetric = cve.metrics?.cvssMetricV31?.[0];

      return {
        id: cve.id,
        description,
        cvssScore: cvssMetric?.cvssData.baseScore || 0.0,
        publishedDate: cve.published,
      };
    });
  } catch (error) {
    console.error('Failed to fetch or parse CVE data:', error);
    // In case of an error, return an empty array or re-throw
    // to be handled by the component.
    throw error;
  }
}
